%% This is an example first chapter.  You should put chapter/appendix that you
%% write into a separate file, and add a line \include{yourfilename} to
%% main.tex, where `yourfilename.tex' is the name of the chapter/appendix file.
%% You can process specific files by typing their names in at the 
%% \files=
%% prompt when you run the file main.tex through LaTeX.
\chapter{Introduction}
\section{Motivation}
Server virtualization is increasingly used in data centers to 
reduce operating costs, improve performance scalability and 
simplify administrative tasks. One reason for the success of
server virtualization is the marriage of isolation and resource 
utilization: it is now possible to assign a dedicated server 
to each application, while reducing wasted cycles by consolidating 
many such virtual servers on a powerful host computer. Over
the next few years, one can expect companies such as VMWare 
to improve the cost-effectiveness of server virtualization by
investing in technologies such as \emph{memory overcommitment} 
that boost virtual machine density per host.

Given the success of server virtualization, many companies are now  
looking to use virtualization for their desktop computers.
In a Virtual Desktop Infrastructure (VDI), desktop operating systems 
and applications are hosted in virtual machines that reside in a data 
center. Users access virtual desktops from a desktop PC or
thin client using a remote display protocol, and get almost the
same experience as if applications were loaded on their local systems.
However, because applications are centrally managed, 
VDI makes desktop administration and management simpler: applications
can quickly be added, deleted, upgraded and patched. 
In fact, because desktop VMs may require less resources than 
server VMs, even higher VM density per host may be achievable
through desktop virtualization.

While a high VM density per host is desireable in general for
effective resource utilization, there are several workloads in which
it can be problematic. In particular, if there are correlated spikes
in the CPU/memory usage of the virtual machines, a high VM density
per host could throttle the host. This can happen if many or all
of the virtual machines hosted by a data center boot up around
the same time, creating a \emph{boot-storm}. Bootstorms
are common e.g. after some software is installed or updated,
or a patch is applied. Bootstorms are also common
in a VDI setting because there is a narrow window of time
in which many workers log in in the morning.

Companies handle bootstorms by using deduplication of data,
staggered boots, or simply avoid them by booting computers in
phases, or by installing expensive/extra-provisioned hardware
equipment. 

With VDI and server virtualization gaining traction, it is
important to fix the boot-storm problem in a way that doesn't 
involve skirting around it. Accidental boot-storms will
probably happen, however many precautions one may take. Furthermore,
leaving computers on for the workforce wastes a lot of energy.
If the workforce computers are wasting cycles staying up,
or booting again and again, perhaps a way to deduplicate 
execution may be exciting.

\section{Goal of Thesis}

Not pursuing a full solution to the bootstorm problem.

Area of inquiry: given different identical VM images, can we 
make the boot process more deterministic? If so, 
deduplication of execution may be a possibility.

1) Statistically understand non-determinism 
in the case of linux services.

2) Figure out the context in which non-determinism
arises and find ways to control it.

Motivated by boostorm problem, because not only can we
do a deduplication of execution, we can improve
page-sharing and improve deduplication of data as well,
by making execution more deterministic.

...but studying non-determinism is an interesting question in its
own right, as explained in the next section.

\section{Importance of Deterministic Execution}\label{ch1:whydeterminism}

Deterministic execution of programs can be beneficial in many
different scenarios, and has motivated the design of Kendo,
a system which enables deterministic multithreading
in applications\cite{}. Our tool complements Kendo because 
it focuses on deterministic execution of single-threaded services in Linux,
at the granularity of individual instructions and their side-effects in
memory.

The motivations for deterministic multhreading listed in
\cite{} apply to this thesis as well.

\subsection{Mainstream Computing and Security}


\subsection{Repeatability}
Users expect programs to produce the same outputs, given the same
inputs. For safety-critical systems, it may
be even better if we can guarantee that given the same inputs,
a program would always execute some {\em precise} 
set of instructions, in the same order, with
the same side-effects. Record/replay systems are not suitable for 
achieving such strong guarantees of repeatability, given the storage
overhead for logs and the typically enormous input space. 
Our system, like Kendo, requires minimal storage to achieve
single-threaded determinism. 

\subsection{Debugging}
Determinism is important for debugging, because developers
often need to reproduce erroneous behavior in
order to diagnose and fix it. Nondeterminism is typically
a major issue for debugging multithreaded applications,
and is a lesser issue for single-threaded
applications. Our work will help developers
easily reproduce erroneous behavior given
the same input for single-threaded applications. 
Record/replay systems have high overhead, so it is unlikely
that the initial buggy execution of a program was recorded.
Deterministic execution also precludes the need for storing
many gigabytes of logs needed for record/replay.

\subsection{Testing}
Deterministic execution in general facilitates testing,
because outputs and internal state can be checked at 
certain points with respect to expected values. Our version
of determinism allows for a particularly strong kind
of test case that may be necessary for safety-critical 
systems: with deterministic execution, a program 
must execute the exact same instructions 
across different executions, for the same inputs.
Test cases can check for deviations from 
the expected instruction sequences.

\section{Contributions}
% Challenges of Determinstic Execution :: Helloworld.c


\subsection{Thesis Organization}





% This is an example of how you would use tgrind to include an example
% of source code; it is commented out in this template since the code
% example file does not exist.  To use it, you need to remove the '%' on the
% beginning of the line, and insert your own information in the call.
%
%\tagrind[htbp]{code/pmn.s.tex}{Post Multiply Normalization}{opt:pmn}

% This is an example of how you would use tgrind to include an example
% of source code; it is commented out in this template since the code
% example file does not exist.  To use it, you need to remove the '%' on the
% beginning of the line, and insert your own information in the call.
%
%\tgrind[htbp]{code/be.s.tex}{Block Exponent}{opt:be}

