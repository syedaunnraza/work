%% This is an example first chapter.  You should put chapter/appendix that you
%% write into a separate file, and add a line \include{yourfilename} to
%% main.tex, where `yourfilename.tex' is the name of the chapter/appendix file.
%% You can process specific files by typing their names in at the 
%% \files=
%% prompt when you run the file main.tex through LaTeX.
\newenvironment{mylisting}
{\begin{list}{}{\setlength{\leftmargin}{1em}}\item\scriptsize\bfseries}
{\end{list}}

\chapter{Sources of Nondeterminism}
This chapter summarizes the myriad sources of nondeterminism
in Linux services encountered in this work. This
study of nondeterminism reveals
the interactions between user-mode
applications, commonly used system libraries (e.g. the \texttt{libc} library),
the Linux operating system and the external world.
Existing literature on nondeterminism is not 
as comprehensive and does not analyze
Linux system calls in as much detail. 

\section{Linux Security Features} \label{ch3:security}
\subsection{Address Space Layout Randomization (ASLR)}
Address Space Layout Randomization (ASLR) involves random arrangement of
key memory segments of an executing program. When ASLR is enabled,
the virtual addresses for the base executable, shared libraries, 
the heap, and the stack are different every time the program is run.
ASLR hinders several kinds of security attacks in which attackers have to predict
program addresses in order to redirect execution (e.g.
\emph{return-to-libc} attacks). 
As mentioned earlier, As mentioned earlier, two execution traces of a
simple ``Hello, World!" program in $C$ are almost entirely different
when ASLR is enabled. Instruction addresses are different; 
memory addresses (especially stack addresses) are all different as well.

Existing record-and-replay systems sometimes overcome ASLR by
forcing the operating system to use the same address space layout across
different runs. A slightly more complicated approach would involve
using base/offset computations to translate equivalent 
addresses between two different executions. 
We simply disabled ASLR for our experiments using the following command:
\texttt {sudo kernel.randomize\_va\_space=0}.

\subsection{Canary Values and Stack Protection}
Copying a \emph{canary} -- a dynamically chosen global value -- onto the stack below the return
address can help detect buffer overflow attacks, because 
an attack that overwrites the return address will also overwrite
the stack copy of the canary. Before a \texttt{ret}, a simple comparison of the global (and unchanged) canary
value with the (possibly changed) stack copy can prevent a buffer overflow attack.

In 32-bit Linux distributions, the $C$ runtime library, 
\texttt{libc}, provides a canary value in \texttt{gs:0x14}.
If stack smashing protection (SSP) is enabled when a program is compiled,
\texttt{gcc} adds instructions that use the canary value
in \texttt{gs:0x14} to detect buffer overflow attacks.
As Pin gets control of the application before \texttt{libc}
initializes \texttt{gs:0x14}, multiple execution traces of a program
will diverge when \texttt{gs:0x14} is initialized and subsequently
read.  The manner in which the canary value in \texttt{gs:0x14} is initialized
depends on the \texttt{libc} version.
If randomization is disabled, \texttt{libc} will store a fixed terminator canary value (0xff0a0000)
in \texttt{gs:0x14}; this does not lead to any nondeterminism.
However, when randomization is enabled, 
some versions of \texttt{libc} store a random word in \texttt{gs:0x14} by reading from \texttt{`/dev/urandom'}
or by using the \texttt{AT\_RANDOM} bytes provided by the kernel (see Section \ref{ch3:rand}). 

Dynamic instrumentation can be used to force canary values
to agree across distinct executions of the same program:
instructions that initialize \texttt{gs:0x14} can be
modified or replaced, or the \texttt{AT\_RANDOM} bytes provided by the kernel can be
modified before they are read by the application, or reads from \texttt{`/dev/urandom'} can be 
intercepted.

\subsection{Pointer Guard / Encryption}
Many stateless APIs return data-pointers to clients 
that the clients are supposed to simply supply as arguments
to subsequent function calls. 
For instance, the \texttt{setjmp} and \texttt{longjmp} functions
can be used to implement a try-catch block in $C$: \texttt{setjmp} uses 
a caller-provided, platform-specific \texttt{jmp\_buf} structure
to store important register state that \texttt{longjmp} later reads to simulate a return from \texttt{setjmp}.
Since the \texttt{jmp\_buf} instance is transparent to clients of \texttt{setjmp}
and \texttt{longjmp}, it is possible that the clients may advertently or inadvertently
overwrite the return address stored in it and cause
\texttt{longjmp} to fail.

Many APIs use simple encryption schemes to detect mangled data structures.
For instance, in 32-bit Linux, \texttt{libc} provides
a {\em pointer guard}  in \texttt{gs:0x18}. This pointer guard has a different value
across multiple runs of a program, just like the \texttt{libc} canary value.
The idea behind the pointer guard is the following: to encrypt a sensitive address $p$, a program
can compute $s = p$  $\oplus  $ \texttt{gs:0x18}, optionally add some bit rotations, and store it in a structure
that gets passed around. Decryption can simply invert any bit rotations, 
and then compute $p = s$ $\oplus  $ \texttt{gs:0x18} back. Any blunt writes to the structure from clients will be detected because 
decryption will likely not produce a valid pointer. 
Pointer encryption is a useful security feature for some APIs
and is used by some versions of \texttt{libc} to protect addresses stored in \texttt{jmp\_buf}
structures.

Initialization of the \texttt{libc} pointer guard can therefore be a source of nondeterminism
program execution. In some versions of \texttt{libc}, the value of \texttt{gs:0x18} is the same
as the value of \texttt{gs:0x14} (the canary). In others,
the value of \texttt{gs:0x14} is \texttt{XOR}ed with 
a random word (e.g. the return value of \texttt{rdtsc} x86 instruction,
or some \texttt{AT\_RANDOM} bytes provided by the kernel) to compute
the pointer guard. In any case, the value of the pointer
guard can be made to agree across different instances
of the same program via dynamic instrumentation: 
the instructions that initialize \texttt{gs:0x18} can
be modified or replaced, or the \texttt{rdtsc} instruction
can be intercepted and emulated, or the  \texttt{AT\_RANDOM} bytes provided by the kernel can be
replaced before they are ever read.

\section{Randomization Schemes} \label{ch3:rand}
As already clear from Section \ref{ch3:security}, 
randomization schemes constitute a major source of nondeterminism 
in programs.
Applications generally use pseudorandom number generators (PRNGs)
for randomization; they rely on the {\em seeds} to the PRNGs
to be different across multiple program executions 
to generate truly random values. PRNG seeds are typically 
computed from several external sources:

\begin{itemize}

\item {\em The} \texttt{`/dev/urandom'}{\em special file}: Linux allows
running processes to access a random number generator through this special file. The entropy generated
from environmental noise (including device drivers)
is used in some implementations for the kernel random number generator.
\item \texttt{AT\_RANDOM} {\em bytes}: 
Making system calls to open, read and close the
\texttt{`/dev/urandom'} file only for a
few random bytes can be computationally expensive. So 
some recent versions of the Linux kernel supply
a few random bytes to all executing programs
through the \texttt{AT\_RANDOM} auxiliary vector.
ELF auxiliary vectors are pushed on the program
stack below command-line arguments and environmental
variables before the program starts executing.

\item {\em The} \texttt{rdtsc} {\em instruction}:
The \texttt{rdtsc} instruction provides an approximate number of ticks since
the computer was last reset, which is stored in a 64-bit register present
on x86 processors. Computing the difference between two successive
calls to \texttt{rdtsc} can be used for timing, whereas a single
value returned \texttt{rdtsc} lacks any useful context.  
The instruction has low-overhead, which makes it suitable for generating a random value
instead of reading from \texttt{`/dev/urandom'}. 

\item {\em The current time or process ID}: Many applications simply make a system call
to get the current time or the process ID, and use the returned value to seed their PRNGs. 

\item {\em Miscellaneous}: There
are several creative ways to seed random number
generators (e.g. {\em www.random.org}),
but thankfully we have not observed them
in the Linux services we have analyzed.
      
\end{itemize}

To overcome nondeterminism resulting from randomization, 
we need to intercept the standard techniques
used by programs to seed PRNGs.
Dynamic instrumentation can be used to 
intercept reads from \texttt{`/dev/urandom'}
and emulate \texttt{rdtsc} instructions.
Nondeterminism from process IDs
can be controlled by virtualizing the process ID
layer (Section \ref{ch3:pid}), and nondeterminism
from time can be controlled by intercepting
time-related system calls and forcing
agreement between concurrently executing 
instances (Section \ref{ch3:time}).

\section{Process Identification Layer} \label{ch3:pid}
% pid, signal(pid), /proc/ filesystem layer

\section{Time} \label{ch3:time}
% time system calls

\section{File I/O}
% file contents;  timestamps in files; file stat(); lengths of logs

\section{Network I/O}
% ephemeral sockets; IP address resolution; timestamps in headers; contents
% statistics on network interfaces

\section{Signals}
% timing e.g. alrms

\section{Inter-thread Communication/Scheduling} 
%scheduler; concurrency

\section{Misc System Calls}
% all statistics


\section{Issues at Stake}
% security: canary aslr etc
% performance & correctness: randomization 
\section {Summary}
